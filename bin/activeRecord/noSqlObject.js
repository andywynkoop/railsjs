const crypto = require('crypto');
const bcrypt = require('bcrypt');
const Inflector = require('inflector-js');
const dbCollection = require('../mongo');
const schema = require('./schema');
const { ObjectId } = require('mongodb');
const schemaValidation = require('./schemaValidation');

class NoSQLObject {

  // Class
  static documentName() {
    return Inflector.pluralize(this.name);
  }

  static async db() {
    const collection = this.documentName();
    const db = await dbCollection(collection);
    return db;
  }

  static async create(params) {
    const instance = new this();
    await instance.assignAttributes(params);
    await instance.afterInitialize();
    return instance;
  }

  // Instance

  constructor() {
    this.setSchema();
    this.defineAttributes();
    this.defineAttrAccessor();
  }

  setSchema() {
    this.schema = schema[this.constructor.documentName()] || null;
  }

  defineAttributes() {
    const { schema } = this;
    let attributes = {};
    if (schema) {
      const attrs = Object.keys(schema);
      attrs.forEach(attr => attributes[attr] = null);
      attributes['_id'] = null;
      Object.preventExtensions(attributes);
      this.enforceAttrs = true;
      this.attributes = attributes;
    } else {
      this.enforceAttrs = false;
      this.attributes = {};
      this.attributes['_id'] = null;
    }
  }

  assignAttributes(params) {
    const { attributes } = this;
    Object.keys(params).forEach(attr => {
      if (!attributes.hasOwnProperty(attr) && this.enforceAttrs) {
        if (this[attr]) {
          this[attr](params[attr]);
        } else {
          throw `Unknown attribute ${attr} for ${this.constructor.documentName()}`;
        }
      } else {
        attributes[attr] = params[attr];
      }
    });
  }

  defineAttrAccessor() {
    Object.keys(this.attributes).forEach(attr => {
      this[attr] = value => {
        if (!value) return this.attributes[attr];
        return this.attributes[attr] = value;
      }
    });
  }

  checkSchemaConstraints() {
    if (!this.enforceAttrs) {
      console.log(`No schema found for ${this.constructor.name}. Define one in the schema directory to enforce attributes.`);  
      return { empty: true };
    }
    return schemaValidation(this);
  }

  afterInitialize() {
    // not implemented
  }

  async insert() {
    const db = await this.constructor.db();
    const response = await db.insertOne( this.attributes );
    const { insertedId } = response;
    if (insertedId) {
      this["_id"](insertedId);
      return this;
    } else {
      return false;
    }
  }

  async update() {
    const db = await this.constructor.db();
    const query = { _id: ObjectId(this["_id"]()) };
    const response = await db.findOneAndUpdate(query, { $set: this.attributes });
    const { value } = response;
    if (value) return this;
    return false;
  }

  async save() {
    const errors = this.checkSchemaConstraints();
    if (errors.empty) {
      if (this.attributes._id) return this.update();
      return this.insert();
    } else {
      this.errors = errors;
      return false;
    }
  }

  async destroy() {
    const db = await this.constructor.db();
    await db.deleteOne({ _id: ObjectId(this._id) });
  }

  // crypto/bcrypt

  // return a promise containing randomly generated bytes of a given size
  secureRandom(size = 16) {
    return new Promise((resolve, reject) => {
      crypto.randomBytes(size, (err, buffer) => {
        if (err) reject(err);
        resolve(buffer.toString('hex'));
      });
    });
  }

  // create a hash from password using bcrypt
  hash(password, saltRounds = 2) {
    return new Promise((resolve, reject) => {
      bcrypt.hash(password, saltRounds, (err, hash) => {
        if (err) reject(err);
        resolve(hash);
      });
    });
  }

  // check a password against a hash using bcrypt
  compare(password, hash) {
    return new Promise((resolve, reject) => {
      bcrypt.compare(password, hash, (err, res) => {
        if (err) reject(err);
        resolve(res);
      });
    });
  }
}

module.exports = NoSQLObject;